// src/lib/teamCanon.ts
export const CANONICAL_TEAMS: string[] = [
  'Time will Tel 1XI','Time will Tel 2XI',
  'Second Wirst 2XI',
  "What's the Wirtz that could happen 1XI","What's the Wirtz that could happen 2XI",
  'Lazio FC 1XI','Lazio FC 2XI',
  'MOBLANDERSON 1XI','MOBLANDERSON 2XI',
  'Porro Ball Defending 1XI',
  'World Club Chumpions 1XI','World Club Chumpions 2XI',
  'Middle Earth FC 1XI','Middle Earth FC 2XI',
  'Ruben Murray 2XI',
  "Pecorino’s 1XI","Pecorino’s 2XI",
  "Jimmy's Jokers 1XI","Jimmy's Jokers 2XI",
  'Smoke AI 1XI','Smoke AI 2XI',
  'Always the Wright One 1XI','Always the Wright One 2XI',
  'Hugo First 1XI',
  'Chicken Cunha 1XI',
  'Thomas the Frank engine 2XI',
];

// If your raw results use different strings (e.g. “1st XI - Time will Tel”,
// “Nick Wright 1XI”), add a DIRECT mapping here.
// Left = raw string exactly as it appears in `results.json`; Right = one of CANONICAL_TEAMS.
export const TEAM_ALIAS_MAP: Record<string, string> = {
  // examples (edit/extend as needed):
  "1XI - Time will Tel": "Time will Tel 1XI",
  "Time will Tell 1st XI": "Time will Tel 1XI",
  "2nd XI - World Club Chumpions": "World Club Chumpions 2XI",
  // "Nick Wright 1XI": "Always the Wright One 1XI",
  // "Nick Wright 2XI": "Always the Wright One 2XI",
};

// Normaliser: tries alias map first; otherwise does a tolerant best-guess match.
const clean = (s: string) =>
  s.toLowerCase().replace(/[’‘]/g, "'").replace(/\u2013|\u2014/g, "-").replace(/\s+/g, " ").trim();

const XI_TOKEN = /\b(1xi|2xi|1st xi|2nd xi|first xi|second xi|1st 11|2nd 11|1s|2s|1's|2's|1 xi|2 xi)\b/i;
const detectXI = (raw: string): '1XI' | '2XI' | null => {
  const r = clean(raw);
  if (/\b2(xi|nd|s|'s| 11)?\b/.test(r)) return '2XI';
  if (/\b1(xi|st|s|'s| 11)?\b/.test(r)) return '1XI';
  return null;
};
const baseOf = (label: string) => label.replace(/\s+(1XI|2XI)$/i, '').trim().toLowerCase();

const canonMeta = CANONICAL_TEAMS.map((c) => ({
  label: c,
  base: baseOf(c),
  xi: c.endsWith('2XI') ? '2XI' : '1XI',
  k: clean(c),
}));

export function toCanonical(raw: string): string | null {
  if (!raw) return null;

  // 1) direct alias
  const aliasHit = TEAM_ALIAS_MAP[raw];
  if (aliasHit) return aliasHit;

  const r = clean(raw);

  // 2) exact canonical match after cleaning
  const direct = canonMeta.find(x => x.k === r);
  if (direct) return direct.label;

  // 3) tolerant base+XI guess
  const xi = detectXI(raw);
  const candidates = xi ? canonMeta.filter(x => x.xi === xi) : canonMeta;
  let best: { label: string; base: string } | null = null;
  for (const c of candidates) {
    if (r.includes(c.base)) {
      if (!best || c.base.length > best.base.length) best = { label: c.label, base: c.base };
    }
  }
  return best?.label ?? null;
}
